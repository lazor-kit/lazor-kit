# Integration Guide

This guide covers advanced integration patterns and best practices for LazorKit SDK.

## Project Setup

### 1. Provider Configuration

Set up the provider at your application root:

```tsx
// App.tsx
import { LazorkitProvider } from '@lazorkit/wallet';

const config = {
  rpcUrl: process.env.REACT_APP_RPC_URL || 'https://api.devnet.solana.com',
  paymasterUrl: process.env.REACT_APP_PAYMASTER_URL || 'https://lazorkit-paymaster.onrender.com',
  ipfsUrl: process.env.REACT_APP_PORTAL_URL || 'https://portal.lazor.sh',
};

export default function App() {
  return (
    <LazorkitProvider {...config}>
      <Router>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/wallet" element={<WalletPage />} />
        </Routes>
      </Router>
    </LazorkitProvider>
  );
}
```

### 2. Environment Configuration

Create environment files for different environments:

```bash
# .env.development
REACT_APP_RPC_URL=https://api.devnet.solana.com
REACT_APP_PAYMASTER_URL=https://lazorkit-paymaster.onrender.com
REACT_APP_PORTAL_URL=https://portal.lazor.sh

# .env.production (when mainnet is available)
REACT_APP_RPC_URL=https://api.mainnet-beta.solana.com
REACT_APP_PAYMASTER_URL=https://your-mainnet-paymaster.com
REACT_APP_PORTAL_URL=https://portal.lazor.sh
```

## Connection Patterns

### Auto-Reconnection on App Start

Implement automatic reconnection when your app loads:

```tsx
// hooks/useAutoConnect.ts
import { useEffect, useCallback } from 'react';
import { useWallet } from '@lazorkit/wallet';

export function useAutoConnect() {
  const { connect, isConnected } = useWallet();

  const autoConnect = useCallback(async () => {
    if (isConnected) return;

    try {
      // connect() automatically tries reconnection first
      await connect();
    } catch (error) {
      // Only log if it's not a "no credentials" error
      if (error.code !== 'NO_STORED_CREDENTIALS') {
        console.error('Auto-connect failed:', error);
      }
    }
  }, [connect, isConnected]);

  useEffect(() => {
    autoConnect();
  }, [autoConnect]);
}

// Usage in App component
function App() {
  useAutoConnect();
  
  return (
    <div>
      {/* Your app content */}
    </div>
  );
}
```

### Connection State Management

Create a custom hook for managing connection states:

```tsx
// hooks/useWalletConnection.ts
import { useState, useCallback } from 'react';
import { useWallet } from '@lazorkit/wallet';

export function useWalletConnection() {
  const { connect, disconnect, isConnected, isConnecting, error } = useWallet();
  const [connectionError, setConnectionError] = useState<string | null>(null);

  const handleConnect = useCallback(async () => {
    setConnectionError(null);
    
    try {
      await connect();
    } catch (error) {
      const message = getConnectionErrorMessage(error);
      setConnectionError(message);
    }
  }, [connect]);

  const handleDisconnect = useCallback(async () => {
    try {
      await disconnect();
      setConnectionError(null);
    } catch (error) {
      console.error('Disconnect failed:', error);
    }
  }, [disconnect]);

  return {
    connect: handleConnect,
    disconnect: handleDisconnect,
    isConnected,
    isConnecting,
    error: connectionError || error?.message,
  };
}

function getConnectionErrorMessage(error: any): string {
  switch (error.code) {
    case 'CONNECTION_FAILED':
      return 'Failed to connect. Please try again.';
    case 'PASSKEY_CREATION_FAILED':
      return 'Failed to create passkey. Please check your browser settings.';
    default:
      return error.message || 'Connection failed';
  }
}
```

## Wallet Components

### Wallet Connection Button

Create a reusable wallet connection component:

```tsx
// components/WalletButton.tsx
import { useWalletConnection } from '../hooks/useWalletConnection';

interface WalletButtonProps {
  className?: string;
  connectText?: string;
  disconnectText?: string;
}

export function WalletButton({ 
  className = '',
  connectText = 'Connect Wallet',
  disconnectText = 'Disconnect'
}: WalletButtonProps) {
  const { connect, disconnect, isConnected, isConnecting, error } = useWalletConnection();

  return (
    <div className={className}>
      {!isConnected ? (
        <button
          onClick={connect}
          disabled={isConnecting}
          className="bg-blue-500 hover:bg-blue-600 disabled:bg-gray-400 px-4 py-2 rounded text-white"
        >
          {isConnecting ? 'Connecting...' : connectText}
        </button>
      ) : (
        <button
          onClick={disconnect}
          className="bg-red-500 hover:bg-red-600 px-4 py-2 rounded text-white"
        >
          {disconnectText}
        </button>
      )}
      
      {error && (
        <p className="text-red-500 text-sm mt-2">{error}</p>
      )}
    </div>
  );
}
```

### Wallet Info Display

Display wallet information when connected:

```tsx
// components/WalletInfo.tsx
import { useWallet } from '@lazorkit/wallet';

export function WalletInfo() {
  const { isConnected, smartWalletPubkey, account } = useWallet();

  if (!isConnected || !smartWalletPubkey) {
    return <div>Wallet not connected</div>;
  }

  const formatAddress = (address: string) => 
    `${address.slice(0, 4)}...${address.slice(-4)}`;

  return (
    <div className="bg-gray-100 p-4 rounded">
      <h3 className="font-semibold mb-2">Wallet Info</h3>
      <div className="space-y-1 text-sm">
        <div>
          <span className="font-medium">Address: </span>
          <span className="font-mono">{formatAddress(smartWalletPubkey.toString())}</span>
        </div>
        <div>
          <span className="font-medium">Type: </span>
          <span>{account?.isCreated ? 'New Wallet' : 'Existing Wallet'}</span>
        </div>
      </div>
    </div>
  );
}
```

## Transaction Handling

### Transaction Hook

Create a hook for handling transactions:

```tsx
// hooks/useTransactions.ts
import { useCallback, useState } from 'react';
import { useWallet } from '@lazorkit/wallet';
import { TransactionInstruction } from '@solana/web3.js';

export function useTransactions() {
  const { signAndSendTransaction, isConnected, isSigning } = useWallet();
  const [lastSignature, setLastSignature] = useState<string | null>(null);
  const [transactionError, setTransactionError] = useState<string | null>(null);

  const sendTransaction = useCallback(async (instruction: TransactionInstruction) => {
    if (!isConnected) {
      throw new Error('Wallet not connected');
    }

    setTransactionError(null);
    setLastSignature(null);

    try {
      const signature = await signAndSendTransaction(instruction);
      setLastSignature(signature);
      return signature;
    } catch (error) {
      const message = error.message || 'Transaction failed';
      setTransactionError(message);
      throw error;
    }
  }, [signAndSendTransaction, isConnected]);

  return {
    sendTransaction,
    isSigning,
    lastSignature,
    error: transactionError,
    clearError: () => setTransactionError(null),
  };
}
```

### SOL Transfer Component

Example transfer component:

```tsx
// components/TransferSOL.tsx
import { useState } from 'react';
import { SystemProgram, PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { useWallet } from '@lazorkit/wallet';
import { useTransactions } from '../hooks/useTransactions';

export function TransferSOL() {
  const { smartWalletPubkey, isConnected } = useWallet();
  const { sendTransaction, isSigning, error } = useTransactions();
  const [recipient, setRecipient] = useState('');
  const [amount, setAmount] = useState('');

  const handleTransfer = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!smartWalletPubkey || !recipient || !amount) return;

    try {
      const recipientPubkey = new PublicKey(recipient);
      const lamports = parseFloat(amount) * LAMPORTS_PER_SOL;

      const instruction = SystemProgram.transfer({
        fromPubkey: smartWalletPubkey,
        toPubkey: recipientPubkey,
        lamports,
      });

      const signature = await sendTransaction(instruction);
      console.log('Transfer completed:', signature);
      
      // Reset form
      setRecipient('');
      setAmount('');
    } catch (error) {
      console.error('Transfer failed:', error);
    }
  };

  if (!isConnected) {
    return <div>Please connect your wallet first</div>;
  }

  return (
    <form onSubmit={handleTransfer} className="space-y-4">
      <div>
        <label className="block text-sm font-medium mb-1">
          Recipient Address
        </label>
        <input
          type="text"
          value={recipient}
          onChange={(e) => setRecipient(e.target.value)}
          placeholder="Enter Solana address"
          className="w-full p-2 border rounded"
          required
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium mb-1">
          Amount (SOL)
        </label>
        <input
          type="number"
          step="0.001"
          min="0"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
          placeholder="0.1"
          className="w-full p-2 border rounded"
          required
        />
      </div>

      <button
        type="submit"
        disabled={isSigning || !recipient || !amount}
        className="w-full bg-green-500 hover:bg-green-600 disabled:bg-gray-400 text-white py-2 px-4 rounded"
      >
        {isSigning ? 'Sending...' : 'Send SOL'}
      </button>

      {error && (
        <p className="text-red-500 text-sm">{error}</p>
      )}
    </form>
  );
}
```

## Advanced Patterns

### Step-by-Step Wallet Creation

For complex onboarding flows:

```tsx
// components/OnboardingFlow.tsx
import { useState } from 'react';
import { useWallet } from '@lazorkit/wallet';

type OnboardingStep = 'welcome' | 'passkey' | 'wallet' | 'complete';

export function OnboardingFlow() {
  const { createPasskeyOnly, createSmartWalletOnly } = useWallet();
  const [step, setStep] = useState<OnboardingStep>('welcome');
  const [passkeyData, setPasskeyData] = useState(null);
  const [isLoading, setIsLoading] = useState(false);

  const handleCreatePasskey = async () => {
    setIsLoading(true);
    try {
      const data = await createPasskeyOnly();
      setPasskeyData(data);
      setStep('wallet');
    } catch (error) {
      console.error('Passkey creation failed:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleCreateWallet = async () => {
    if (!passkeyData) return;
    
    setIsLoading(true);
    try {
      await createSmartWalletOnly(passkeyData);
      setStep('complete');
    } catch (error) {
      console.error('Wallet creation failed:', error);
    } finally {
      setIsLoading(false);
    }
  };

  switch (step) {
    case 'welcome':
      return (
        <div className="text-center">
          <h2 className="text-2xl font-bold mb-4">Welcome to LazorKit</h2>
          <p className="mb-6">Create your secure wallet using passkeys</p>
          <button
            onClick={() => setStep('passkey')}
            className="bg-blue-500 text-white px-6 py-2 rounded"
          >
            Get Started
          </button>
        </div>
      );

    case 'passkey':
      return (
        <div className="text-center">
          <h2 className="text-2xl font-bold mb-4">Create Passkey</h2>
          <p className="mb-6">First, we'll create your secure passkey</p>
          <button
            onClick={handleCreatePasskey}
            disabled={isLoading}
            className="bg-green-500 text-white px-6 py-2 rounded disabled:bg-gray-400"
          >
            {isLoading ? 'Creating...' : 'Create Passkey'}
          </button>
        </div>
      );

    case 'wallet':
      return (
        <div className="text-center">
          <h2 className="text-2xl font-bold mb-4">Deploy Wallet</h2>
          <p className="mb-6">Now let's deploy your smart wallet</p>
          <button
            onClick={handleCreateWallet}
            disabled={isLoading}
            className="bg-purple-500 text-white px-6 py-2 rounded disabled:bg-gray-400"
          >
            {isLoading ? 'Deploying...' : 'Deploy Wallet'}
          </button>
        </div>
      );

    case 'complete':
      return (
        <div className="text-center">
          <h2 className="text-2xl font-bold mb-4">🎉 Welcome!</h2>
          <p className="mb-6">Your wallet is ready to use</p>
          <button
            onClick={() => window.location.reload()}
            className="bg-blue-500 text-white px-6 py-2 rounded"
          >
            Continue to App
          </button>
        </div>
      );
  }
}
```

### Persistent State with Zustand

For more complex state management:

```tsx
// store/walletStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface WalletStore {
  lastConnectedWallet: string | null;
  userPreferences: {
    autoConnect: boolean;
    theme: 'light' | 'dark';
  };
  setLastConnectedWallet: (address: string | null) => void;
  setUserPreferences: (prefs: Partial<WalletStore['userPreferences']>) => void;
}

export const useWalletStore = create(
  persist<WalletStore>(
    (set) => ({
      lastConnectedWallet: null,
      userPreferences: {
        autoConnect: true,
        theme: 'light',
      },
      setLastConnectedWallet: (address) => 
        set({ lastConnectedWallet: address }),
      setUserPreferences: (prefs) => 
        set((state) => ({ 
          userPreferences: { ...state.userPreferences, ...prefs } 
        })),
    }),
    {
      name: 'lazorkit-wallet-store',
    }
  )
);
```

## Best Practices

### 1. Error Boundary

Wrap your wallet components with error boundaries:

```tsx
// components/WalletErrorBoundary.tsx
import { Component, ReactNode } from 'react';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class WalletErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="text-center p-4">
          <h2 className="text-xl font-bold text-red-600 mb-2">
            Wallet Error
          </h2>
          <p className="text-gray-600 mb-4">
            Something went wrong with the wallet connection.
          </p>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            className="bg-blue-500 text-white px-4 py-2 rounded"
          >
            Try Again
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

### 2. Loading States

Always provide clear loading feedback:

```tsx
function WalletAction() {
  const { isSigning, signAndSendTransaction } = useWallet();
  
  return (
    <button disabled={isSigning}>
      {isSigning ? (
        <span className="flex items-center">
          <LoadingSpinner className="mr-2" />
          Signing...
        </span>
      ) : (
        'Send Transaction'
      )}
    </button>
  );
}
```

### 3. Network Detection

Handle network-specific logic:

```tsx
function useNetwork() {
  const [network, setNetwork] = useState<'devnet' | 'mainnet'>('devnet');
  
  useEffect(() => {
    const rpcUrl = process.env.REACT_APP_RPC_URL || '';
    const isMainnet = rpcUrl.includes('mainnet');
    setNetwork(isMainnet ? 'mainnet' : 'devnet');
  }, []);
  
  return { network, isMainnet: network === 'mainnet' };
}
```
